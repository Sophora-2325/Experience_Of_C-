a.count( target - nums[i]>0)，作用为计算列表 a 中是否存在值为 target - nums[i] 的元素
a.count() 计算出现次数


hash表只是并没有什么稀奇的，就是单纯的map利用，这个东西利用了map中键的唯一性与值的可变性来定位某个数值。

map<int,int>a;
vector<int>b(2,-1);
for(int i=0;i<nums.size();i++){
  a.insert(map<int,int>::value_type(nums[i],i));
  for(int i=0;i<nums.size();i++){
    if(a.count(target-nums[i]>0&&a[target-nums[i]!=i])){
        b[0]=target-nums[i];
        b[1]=i;
    }
  }
}


链表也没啥大不了的，就是单纯对指针的使用，而且ListNode还是用struct结构体做出来的，这些数据结构很多都是由简单的数组合出来的
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int len1=1;//记录l1的长度
        int len2=1;//记录l2的长度
        ListNode* p=l1;
        ListNode* q=l2;
        while(p->next!=NULL)//获取l1的长度
        {
            len1++;
            p=p->next;
        }
        while(q->next!=NULL)//获取l2的长度
        {
            len2++;
            q=q->next;
        }
        if(len1>len2)//l1较长，在l2末尾补零
        {
            for(int i=1;i<=len1-len2;i++)
            {
                q->next=new ListNode(0);
                q=q->next;
            }
        }
        else//l2较长，在l1末尾补零
        {
            for(int i=1;i<=len2-len1;i++)
            {
                p->next=new ListNode(0);
                p=p->next;
            }
        }
        p=l1;
        q=l2;
        bool count=false;//记录进位
        ListNode* l3=new ListNode(-1);//存放结果的链表
        ListNode* w=l3;//l3的移动指针
        int i=0;//记录相加结果
        while(p!=NULL&&q!=NULL)
        {
            i=count+p->val+q->val;
            w->next=new ListNode(i%10);
            count=i>=10?true:false;
            w=w->next;
            p=p->next;
            q=q->next;
        }
        if(count)//若最后还有进位
        {
            w->next=new ListNode(1);
            w=w->next;
        }
        return l3->next; 
    }
};


双指针+hash集合
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> charSet;  // 记录当前窗口中的字符
        int left = 0;                 // 窗口左边界
        int maxLen = 0;               // 最长子串长度
        
        for (int right = 0; right < s.length(); right++) {
            // 如果右指针字符已存在于集合中，移动左指针直到移除重复字符
            while (charSet.find(s[right]) != charSet.end()) {
                charSet.erase(s[left]);
                left++;
            }
            // 将当前字符加入集合，更新最大长度
            charSet.insert(s[right]);
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
更快更好的版本
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> st;
        int maxL = 0, left = 0;
        for(int i = 0; i < s.length(); i++) {
            if(st.count(s[i])) {
    
                left = max(left, st[s[i]] + 1);
            }
            maxL = max(maxL, i - left + 1);
            st[s[i]] = i;
        }
        return maxL;
    }
};
